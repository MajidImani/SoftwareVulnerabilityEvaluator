/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package softwaresecurityevaluator.core;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import softwaresecurityevaluator.datareader.GithubReleaseVersionReader;
import softwaresecurityevaluator.model.CVEData;
import softwaresecurityevaluator.model.CVEItem;
import softwaresecurityevaluator.model.ReferenceData;

/**
 *
 * @author Majid
 */
public class VulnerabilityProposedScore {

    List<Software> softwares;
    private boolean isMetricV3;
    private List<String> softwareNames;
    private CVEData cVEData;
    private GithubReleaseVersionReader githubVersionReader;

    public VulnerabilityProposedScore(List<String> softwareNames, CVEData cVEData) {
        this.cVEData = cVEData;
        this.softwareNames = softwareNames;
        softwares = new LinkedList<Software>();
        githubVersionReader = new GithubReleaseVersionReader();
    }

    public void calculateProposedScore(boolean isMetrivV3) {
        this.isMetricV3 = isMetrivV3;
        calculatePerSoftware();
    }

    private void calculatePerSoftware() {
        for (int i = 0; i < softwareNames.size(); i++) {
            Software soft = new Software();
            soft.setName(softwareNames.get(i));
            soft.setFeature_1_VulnerabilitySeverityScore(calculateFeature_1_VulnerabilitySeverity(soft.getName()));
            soft.setFeature_2_Vulnerability_FrequencyScore(calculateFeature_2_Vulnerability_Frequency(soft.getName()));
            softwares.add(soft);
        }
        ScaleFeature_2_Vulnerability_Frequency();
        for (int i = 0; i < softwares.size(); i++) {
            Software soft = softwares.get(i);
            soft.setFeature_3_ExistenceOfExploitsScore(calculateFeature_3_ExistenceOfExploits(soft.getName()));
            soft.setFeature_4_ExposureTimeScore(calculate_Feature_4_ExposureTime(soft.getName()));
            double score = calculateProposedScore(soft);
            System.out.println(soft.getName() + " proposed score is  " + score);
            soft.setProposedScore(score);
            softwares.set(i, soft);
        }
    }

    private double calculateFeature_1_VulnerabilitySeverity(String softName) {
        if (cVEData.CVE_Items.size() == 0) {
            return 0;
        }
        double cvss = 0;
        long counter = 0;
        for (int i = 0; i < cVEData.CVE_Items.size(); i++) {
            CVEItem cVEItem = cVEData.CVE_Items.get(i);
            if (CVEDataHandler.IsCveItemContainsSoftware(cVEItem, softName)) {
                if (isMetricV3) {
                    cvss += cVEItem.impact.baseMetricV3.cvssV3.baseScore;
                } else {
                    cvss += cVEItem.impact.baseMetricV2.cvssV2.baseScore;
                }
                counter++;
            }
        }
        System.out.println(softName + " => Feature_1_VulnerabilitySeverity is: " + cvss / counter);
        return cvss / counter;
    }

    private double calculateFeature_2_Vulnerability_Frequency(String softName) {
        long numberOfVulnerability = 0;
        long totalVulnerabilities = cVEData.CVE_Items.size();
        LocalDateTime firstVulnerabilityDate = LocalDateTime.now();
        LocalDateTime now = LocalDateTime.now();
        for (int i = 0; i < cVEData.CVE_Items.size(); i++) {
            CVEItem cVEItem = cVEData.CVE_Items.get(i);
            if (CVEDataHandler.IsCveItemContainsSoftware(cVEItem, softName)) {
                numberOfVulnerability++;
                DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm'Z'", Locale.ENGLISH);
                LocalDateTime publishedDate = LocalDateTime.parse(cVEItem.publishedDate, dateFormatter);
                //System.out.println(cVEItem.publishedDate + " , " + publishedDate);
                if (publishedDate.isBefore(firstVulnerabilityDate)) {
                    firstVulnerabilityDate = publishedDate;
                }
            }
        }
        //System.out.println(firstVulnerabilityDate);
        LocalDateTime tempDateTime = LocalDateTime.from(firstVulnerabilityDate);
        long months = tempDateTime.until(now, ChronoUnit.MONTHS);
        double average = (double) numberOfVulnerability / months;
        System.out.println(softName + " => Feature_2_Vulnerability_Frequency is: " + average);
        return average;
    }

    private double calculateFeature_3_ExistenceOfExploits(String softName) {
        long numberOfVulnerability = 0;
        long numberOfExploits = 0;
        for (int i = 0; i < cVEData.CVE_Items.size(); i++) {
            CVEItem cVEItem = cVEData.CVE_Items.get(i);
            if (CVEDataHandler.IsCveItemContainsSoftware(cVEItem, softName)) {
                numberOfVulnerability++;
                if (cVEItem.cve != null && cVEItem.cve.references != null && cVEItem.cve.references.reference_data != null) {
                    List<ReferenceData> refData = cVEItem.cve.references.reference_data;
                    for (int j = 0; j < refData.size(); j++) {
                        if (refData.get(j).tags.contains("Exploit")) {
                            numberOfExploits++;
                        }
                    }
                }
            }
        }
        //System.out.println(numberOfVulnerability + " , " + numberOfExploits);
        double average = (double) numberOfExploits / numberOfVulnerability;
        //double scaledAverage = 10 * (average / totalVulnerabilities);
        System.out.println(softName + " => Feature_3_ExistenceOfExploits is: " + 10 * average);
        return 10 * average;
    }

    private double calculate_Feature_4_ExposureTime(String softName) {
        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm'Z'", Locale.ENGLISH);
        LocalDateTime publishedDate;
        LocalDateTime lastReleaseDate = githubVersionReader.getLastReleaseDate(softName);
        long totalDiffs = 0;
        long counter = 0;
        for (int i = 0; i < cVEData.CVE_Items.size(); i++) {
            CVEItem cVEItem = cVEData.CVE_Items.get(i);
            if (CVEDataHandler.IsCveItemContainsSoftware(cVEItem, softName)) {
                publishedDate = LocalDateTime.parse(cVEItem.publishedDate, dateFormatter);
                long minutes = ChronoUnit.MINUTES.between(publishedDate, lastReleaseDate);
                counter++;
                totalDiffs += minutes;
            }
        }
        double average = totalDiffs / counter < 0 ? 0 : totalDiffs / counter;
        System.out.println(softName + " => Feature_4_ExposureTime is: " + (10 / 12.3) * Math.log1p(average + 1));
        return (10 / 12.3) * Math.log1p(average + 1);
    }

    private double calculateProposedScore(Software soft) {
        return (0.25) * (soft.getFeature_1_VulnerabilitySeverityScore()
                + soft.getFeature_2_Vulnerability_FrequencyScore()
                + soft.getFeature_3_ExistenceOfExploitsScore()
                + soft.getFeature_4_ExposureTimeScore());
        
        // for computing  => SVE score 1
//        return (0.5) * (soft.getFeature_1_VulnerabilitySeverityScore()
//                + soft.getFeature_2_Vulnerability_FrequencyScore());
    }

    private void ScaleFeature_2_Vulnerability_Frequency() {
        double maximum = Math.log(softwares.get(0).getFeature_2_Vulnerability_FrequencyScore());
        double minumum = Math.log(softwares.get(0).getFeature_2_Vulnerability_FrequencyScore());
        for (int i = 1; i < softwares.size(); i++) {
            double frequency = Math.log(softwares.get(i).getFeature_2_Vulnerability_FrequencyScore());
            if (frequency > maximum) {
                maximum = frequency;
            }
            if (frequency < minumum) {
                minumum = frequency;
            }
        }
//        System.out.println("Minumum Feature_2_Vulnerability_Frequency is: " + minumum);
//        System.out.println("Maximum Feature_2_Vulnerability_Frequency is: " + maximum);
        for (Software software : softwares) {
            double scaledValue = (10 / maximum) * (Math.log(Math.log(software.getFeature_2_Vulnerability_FrequencyScore() + (1 - minumum))));
            //System.out.println("Feature_2_Vulnerability_Frequency Scaled Value is: " + scaledValue);
            software.setFeature_2_Vulnerability_FrequencyScore(scaledValue);
        }

    }
}
